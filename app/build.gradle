apply plugin: 'com.android.application'
apply from: '../config.gradle'
android {
    compileSdkVersion this.ext.android.compileSdkVersion
    buildToolsVersion this.ext.android.buildToolsVersion

    defaultConfig {
        applicationId this.android.applicationId
        minSdkVersion this.android.minSdkVersion
        targetSdkVersion this.android.targetSdkVersion
        versionCode this.android.versionCode
        versionName this.android.versionName

        testInstrumentationRunner this.android.versionName
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }

    android {
        lintOptions {
            abortOnError false
        }
    }


}
//为应用程序添加第三方库依赖
dependencies {
    //文件树fileTree,file():单个文件 files()多个文件
    implementation fileTree(dir: 'libs', include: ['*.jar'])

    testImplementation this.dependencie.junit
    androidTestImplementation this.dependencie.runner
    androidTestImplementation this.dependencie.supportEspresso
    implementation this.dependencie.supportDesign
    //第三方引入依赖会打入jar包、war包
    compile(this.dependencie.support_v13) {
        //排除依赖
        exclude('module': 'support-v4')
        //传递依赖 false：禁止传递依赖，不能引入第三方库 true:可以引用第三方库
        transitive false
    }
    //只在编译期间起作用，不在运行期间起作用
    //provided(this.dependencie.supportDesign)
}

/**
 * 执行外部命令
 */

task(name: 'apkcopy', 'apkcopy') {
    Task task ->
        //gradle执行阶段去执行
        task.doLast {
            def sourcePath = getBuildDir().path + "/outputs/apk"
            def targetPath = "/Users/tianyejun/Downloads/"
            def command = "mv -f ${sourcePath} ${targetPath}"
            try {
                //执行命令
                exec {
                    executable 'bash'
                    args '-c', command
                    println "命令执行完毕"
                }
            } catch (GradleException e) {
                e.printStackTrace()
            }
        }
}

/**
 *> （1）Task创建方式
 * 1.直接通过task函数创建
 * task('helloTask'){}
 * 2.TaskContainer创建
 * getTasks().create('task名称'){}
 * >（2）Task配置
 */

/**
 * Task第一种创建方式
 */
task('helloTask') {
    println "Task第一种创建方式---helloTask"
}
/**
 * Task第一种创建方式
 */
getTasks().create("secondTask") {
    println "Task第二种创建方式--secondTask"
}

/**
 * 第一种配置方式
 */

task(group: "config", description: "config第一种方式", 'taskConfig1') {
    println "Task第一种配置方式---taskConfig1"
    doFirst {
        println "Task group name is $group"
    }
}

/**
 * 第二种配置方式
 */

task('taskConfig2') {
    Task task ->
        task.group ="config"
        task.description = "config第二种方式"
        println "Task第二种配置方式---taskConfig2"
}

/**
 * 计算build执行时长
 */
def startBuildTime,endBuildTime
afterEvaluate {
    Project project ->
        def preBuildTask = project.getTasks().getByName("preBuild")
        preBuildTask.doFirst {
            startBuildTime = System.currentTimeMillis()
            println "开始时间为：$startBuildTime"
        }
        def buildTask = project.getTasks().getByName("build")
        buildTask.doLast {
            endBuildTime = System.currentTimeMillis()
            println "build时长为：${endBuildTime - startBuildTime}"
        }
}

/**
 * Task依赖方式
 * 1.dependsOn
 */
task("taskX"){
    doLast {
        println "taskX"
    }
}
task("taskY"){
    doLast {
        println "taskY"
    }
}
println "dependsOn 第一种依赖方式"
task("taskZ" ,dependsOn: [taskX,taskY]){
    println "taskZ"
}
println "dependsOn 第二种依赖方式"
taskZ {}.dependsOn(taskX,taskY)

/**
 * task1依赖以lib开头的Task
 */

task("lib1"){
    doLast {
        println "lib1"
    }
}

task("lib2"){
    doLast {
        println "lib2"
    }
}
task("nolib"){
    doLast {
        println "nolib"
    }
}

task("task3"){
    Task tsk->
        tsk.dependsOn = this.tasks.findAll {
            return it.name.startsWith("lib")
        }
        tsk.doLast {
            println "执行task依赖lib开头的task"
        }
}

println ""
task("handleRelaseFile"){
    def srcFile = file('release.xml')
    def destDir = new File(this.getBuildDir().path,'generated/release/')
    doLast {
        if(!destDir.isDirectory()){
            destDir.mkdirs()
        }
        def releases = new XmlParser().parse(srcFile)
        releases.release.each{
            def node ->
                def versionName = node.versionName.text()
                def versionCode = node.versionCode.text()
                def versionInfo = node.versionInfo.text()
                println "versionName =${versionName} versionCode=${versionCode} versionInfo${versionInfo}"
                //创建文件并写入节点
                def destFile = new File(destDir.path,"release-${versionName}.text")
                destFile.withWriter {
                    def writer ->
                        writer.write("${versionName}--->${versionCode}--->${versionInfo}")
                }
        }
    }
}

task ("handleRealseFileTest",dependsOn: handleRelaseFile){
    def dir = fileTree(this.getBuildDir().path+'/generated/release/')
    doLast {
        dir.each {
            println "the file name is ${it}"
        }
        println "文件输出完成"
    }
}